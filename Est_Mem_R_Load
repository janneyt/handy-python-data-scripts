import sys


IS_VALID = ["-h","-o","-e","-8n","-idk","-c","-4i"]
MSG_VALID = ("\nThe valid options for this program are:\n\t-h (help)"
               +"\n\t-o (valid options)\n\t-e (exit)\n\t-8n for 8 byte numeric"
               +"data\n\t-4i for 4 byte integer data\n\t-c for characters\n\t-idk"
               +"if you need help selecting a datatype\n")
MSG_INT_INVALID = ("\nPlease only select a valid integer as listed above,"
                     +" without periods, letters or any other character.\n")
ALL_INVALID = ("\nYou have selected in invalid option.\nPlease select a valid"
                 +"option.\nIf you do not know the valid options, press -o and"
                 +"one will be assigned to you.\n")
INITIAL_MSG = ("\nPlease identify the largest data type for the file.\nPress"
                 +"-h for help, -o to see valid options, -e to exit.\n")
SCFL_CALC_MSG = ("\nWould you like to run another calculation (Y),"
                 +"or press -e to exit.\n")

NOT_A_STRING = ("\nYou attempted a command line argument that was not a string. "
                +"\nPlease enter a character of the alphabet (A-Z, a-z)"
                +"\npreceded by a dash (-).\n")

'''
################################################################################
Input Functions
################################################################################
'''

def get_input(nxt_input):
    '''
    Gets input from the user and makes sure it is valid.

    Is this functional? The input is a string, theoretically. It does not mutate
    in any way through this function, and is in turn passed to another function.

    The only actual way to exit the function is through the evaluate_for_options
    function. This is entered through a "true" evaluation in the if/else control
    statement. The else clause just calls get_input after soliciting input.

    This is not a recursive function per se, although the else statement looks
    recursive.

    Raises an exception if someone tries to pass input that isn't a string.
    If the str() function succeeds it *Technically* violates functional programming.

    Restrictions on use: requires string input preceded by a dash. Not suitable
    for other types of input.

    '''
    try:
        str(nxt_input)
        if nxt_input in IS_VALID:
            evaluate_for_options(nxt_input)
        else:
            print(ALL_INVALID)
            command = input(MSG_VALID)
            get_input(command)
    except Exception as e:
        print(e)
        print(NOT_A_STRING)
        command = input(MSG_VALID)
        get_input(command)

'''
################################################################################
Exit Functions
################################################################################
'''

def evaluate_for_exit():
    '''
    Confirms user really wants to exit program, then exits or not as appropriate.

    There is no global state interacted with at all in this function. It is
    merely a confirmation of exit. Again, the functional nature of testing the
    input is disputable, but I don't really see a way to do it otherwise.

    Exceptions should be raised if a string is not passed as input.


    '''
    response = input("\nDo you want to exit this program? Y/n\n")
    type(response)
    try:
        str(response)
        if response == "Y":
            sys.exit()
        elif response == 'n':
            get_input("-o")
        else:
            get_input("-o")
    except Exception as e:
        print(e)
        print(NOT_A_STRING)
        evaluate_for_exit()

def query_exit():
    '''
    Queries if user wants to calculate the size of other files, or to exit.


    '''
    response4 = input(SCFL_CALC_MSG)
    if response4 == "Y":
        get_input("-o")
    elif response4 == "n":
        evaluate_for_exit()
    else:
        print(ALL_INVALID)
        query_exit()

'''
################################################################################
Assistance Functions (Help Menu)
################################################################################
'''
def evaluate_for_char():
    '''
    Calculates the size of a string based on the size of a character being one
    byte.

    I'm assuming that the longest string is relatively easy to find. Further
    development would calculate this. Also, based on the R documentation, a
    character is stored as one byte. I need to verify this more rigorously since
    it would make an integer (4 bytes) larger than a character (1 byte).
    '''
    print("\nThe data is probably characters, at 1 bytes per character value.")
    longest_character = input("\nWhat is the longest string in the dataset?\n")
    calculate_approximate_memory(longest_character)


def evaluate_for_options(nxt_input):
    '''
    Evaluates input and directs to appropriate function.

    I don't like switch statements usually. This could have been written as a
    switch but at least in python there isn't a large computational difference
    and I prefer the nomenclature (if, elif, else) rather than (case).
    '''
    if nxt_input == '-h':
        evaluate_for_help()
    elif nxt_input == '-o':
        print(MSG_VALID)
        get_input(input(INITIAL_MSG))
    elif nxt_input == '-e':
        evaluate_for_exit()
    elif nxt_input == '-8n':
        calculate_approximate_memory(8)
    elif nxt_input == '-idk':
        walkthrough_data_types()
    elif nxt_input == '-4i':
        calculate_approximate_memory(4)
    elif nxt_input == '-c':
        evaluate_for_char()
    else:
        print("not a current valid options, how did it get here?")
        command = input(ALL_INVALID)
        get_input(command)


def walkthrough_data_types():
    '''
    Helps the user decide what datatype is being used in the csv file.

    Note that there are two situations where the function calls itself. Both
    are meant to alert the user that they are entering invalid input.
    '''
    print("\nByte encoding information from:"
         +"https://www.stat.auckland.ac.nz/~paul/ItDT/HTML/node76.html")
    response1 = input("Is there a decimal place, a negative number, or anything"
                     +"else that coerces to a numeric?\nThis includes long"
                     +"integers and floats. Y/n\n")
    if response1 == 'Y':
        print("\nThe size of all data from your dataset is 8 bytes per entry."
             +"\nThis may be an overreaction but is a good upper bound.\n")
        print("\nStarting calculation with 8 bytes per entry\n")
        calculate_approximate_memory(8)
    elif response1 == 'n':
        response2 = input("Are there any numbers at all? Y/n")
        if response2 == 'Y':
            print("\nThe size of all data from your dataset is 4 bytes per"
                 +"entry.\nThis may be an overreaction but is a good upper bound.\n")
            calculate_approximate_memory(4)
        elif response2 == 'n':
            evaluate_for_char()
        else:
            print(ALL_INVALID)
            print("\n")
            walkthrough_data_types()
    else:
        print(ALL_INVALID)
        print("\n")
        walkthrough_data_types()


def evaluate_for_help():
    '''
    Evaluates input to help user to decide what type of help they need.
    '''
    nc = input("\n\nPlease select from the following options:"
              +"\n1. I'm not sure what command line option to use"
              +"\n2. I'm not sure what the biggest data type is\n")
    if nc == "1":
        evaluate_for_options("-o")
    elif nc == "2":
        walkthrough_data_types()
    else:
        print(MSG_INT_INVALID)
        get_input(INITIAL_MSG)


'''
################################################################################
Calculation Function (Help Menu)
################################################################################
'''

def calculate_approximate_memory(data_bytes):
    '''
    Performs the actual calculation of memory size.

    Basic mathematical calculation is rows in csv file, multiplied by columns in
    csv file, and finally result is multiplied by the input (number of bytes
    in data type).
    Input: an integer
    Outputs:

    '''
    rows = input("\nHow many rows are in the data file?\n")
    try:
        int_rows = int(rows)
    except:
        print("\nCannot convert to integer\n")
        rows = input(MSG_INT_INVALID)
    columns = input("\nHow many columns are in the data file?\n")
    try:
        int_columns = int(columns)

    except:
        print("\nCannot convert to integer\n")
        columns = input(MSG_INT_INVALID)
    try:
        int_data_bytes = int(data_bytes)
    except:
        print("\nSomehow the data size was passed as something other than a number.\nPlease enter again as a number 0-9 on the keyboard, and NOTHING ELSE.\n")
        calculate_approximate_memory(input())

    #This is the *actual* calculation.
    #Rule of thumb is the amount of memory needed to read in for R datasets is
    #twice the size of the dataset sitting in memory. So size doubles the calculation.
    size = (int_rows * int_columns * int(data_bytes))/(2**20)*2

    print("Your estimated R file size is: ",size," MB")
    query_exit()




command = input(INITIAL_MSG)
get_input(command)
